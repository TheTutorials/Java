# 面向对象
* Java 中一切皆对象

## 类的定义
``` java
访问修饰符 class 类名 {
    成员属性和方法定义...
}
```
如
``` java
class Person {
  String name = "Java";
  public void sayHi() {
    System.out.println(name);
  }
}
```

## 类的初始化
* 类是创建对象的模版（蓝图）
* 使用关键词 `new` 创建类对应的实体
* 使用关键词 `new` 创建的对象存储在堆空间里
* 成员变量可以不初始化，有默认值
``` java
class Person {
  String name;
  int age;
}

new Person(); //匿名对象
Person jack = new Person(); //创建对象并保存对象的引用
```

## 访问对象成员
``` java
public class Student {
  String name; //学生姓名
  int age; //学生年龄

  public static void main(String[] args) {
    Student jack = new Student();
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:null，年龄是:0
    jack.name = "Jack"; // 修改姓名
    jack.age = 25; // 修改年龄
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:Jack，年龄是:25

    Student tom = new Student();
    tom.name = "Tom";
    tom.age = 20;
    System.out.println("学生的名字:" + tom.name + "，年龄是:" + tom.age); // 学生的名字:Tom，年龄是:20
  }
}
```

<details>
<summary>例题: 定义一个Point对象表示点<br/>
</summary>

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    System.out.println("x = " + point.x + ", y = " + point.x);
  }
}
```
</details>

## 方法的定义
``` java
[访问修饰符] 返回值类型 函数名(参数列表) {
  函数体
} 
```

* 访问修饰符: `public` `private` `protect` `default`
* 返回值类型: 8大基本数据类型以及引用类型都可以作为返回值类型，如果不需要返回值，声明为 `void`
* 函数名: 遵循变量命名规则
* 参数列表: 声明函数所需要接受的参数，从主调函数传递而来，如果不需要传递任何参数可以直接空着
* 函数题: 根据参数列表执行相应的运算，然后返回运算结果（如果需要)

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public void show() {
    System.out.println("x = " + x + ", y = " + x);
  }

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    point.show();
  }
}
```

## 方法的调用
* 函数名(实际参数)
* 实际参数传递给形式参数用于初始化形式参数
* 实参列表和形参数列表必须保持类型和数量一致
* 实际参数可以传递常量、变量、表达式、方法调用等

<details>
<summary>例题: 定义由参数成员函数修改成员属性值<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄
  double height; //身高

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public void setHeight(double newHeight) {
    height = newHeight;
  }

  public void setInfo(String newName, int newAge, double newHeight) {
    name = newName;
    age = newAge;
    height = newHeight;
  }

  public void showInfo() {
    System.out.println("姓名:" + name + "\t年龄:" + age + "\t身高:" + height);
  }
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.setHeight(2.0);
    people.showInfo();

    People jack = new People();
    jack.setInfo("Jack", 22, 2.21);
    jack.showInfo();
  }
}
```
</details>

## 可变长参数函数定义
* 参数的数量根据实际情况而决定
* 可以是0个或者多个
* 一个方法只允许有一个可变参数，并且只能位于最后一个位置

<details>
<summary>例题: 可变参数求任意个数字求和<br/>
</summary>

``` java
public class VarParametersTest {
  public int sum(int... nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public static void main(String[] args) {
    VarParametersTest varParametersTest = new VarParametersTest();
    System.out.println(varParametersTest.sum()); // 0
    System.out.println(varParametersTest.sum(1)); // 1
    System.out.println(varParametersTest.sum(1, 2)); // 3
    System.out.println(varParametersTest.sum(1, 2, 3)); // 5
    int[] nums = {1, 2, 3, 4, 5};
    System.out.println(varParametersTest.sum(nums)); // 15
  }
}
```
</details>

<details>
<summary>例题: 无参数有返回值案例<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);

    String returnName = people.getName();
    int returnAge = people.getAge();
    System.out.println(returnName);
    System.out.println(returnAge);
  }
}
```
</details>

注意: 
* 形式参数的改变不会影响实际参数的改变，因为他们存在于不同的栈空间
* 传递引用参数时，形式参数通过引用改变内容，同时回修改实际参数的内容
* 形式参数改变引用指向时候，改变形式参数不会影响到实际参数
``` java
public class ChangeArgs {
  public void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("swap函数中的a = " + a + ", b = " + b); // swap函数中的a = 4, b = 3
  }

  public static void main(String[] args) {
    int a = 3;
    int b = 4;
    System.out.println("交换前: a = " + a + ", b = " + b); // 交换前: a = 3, b = 4
    new ChangeArgs().swap(a, b);
    System.out.println("交换后: a = " + a + ", b = " + b); // 交换后: a = 3, b = 4  
  }
}
```

``` java
public class ChangeArgs {
  public void swap(int[] nums) {
    int temp = nums[0];
    nums[0] = nums[1];
    nums[1] = temp;
  }

  public static void main(String[] args) {
    int[] nums = {3, 4};
    System.out.println("交换前:" + Arrays.toString(nums)); // 交换前:[3, 4]
    new ChangeArgs().swap(nums);
    System.out.println("交换后:" + Arrays.toString(nums)); // 交换后:[4, 3]
  }
}
```

## 方法调用内存结构
* 栈用于存放程序运行时的所有局部变量
* 每次的函数调用会在栈中开辟对应的空间，存储该方法的局部变量
* 方法返回时候，栈顶弹出，返回到上一个主调函数


## 构造方法
* 用于创建对象时，初始化成员属性
* 构造方法没有返回值
* 构造方法方法名和类名保持一致
* 构造方法只能使用 `new` 关键词调用
* 如果没有显示声明构造方法，系统默认添加一个无参数构造方法
* 如果已经定义了构造方法，系统不会默认提供无参构造方法，如果需要需要手动定义

<details>
<summary>例题: 无参数构造方法的调用<br/>
</summary>

``` java
class Computer {
  public String color;
  public double price;
  public Computer() {
    System.out.println("构造方法被调用了");
    color = "红色";
    price = 19999;
  }
  public void showComputerInfo() {
    System.out.println("电脑颜色: " + color + ", 电脑价格: " + price);
  }
}
public class ConstructorTest {
  public static void main(String[] args) {
    Computer computer = new Computer(); // 构造方法被调用了
    computer.showComputerInfo(); // 电脑颜色: 红色, 电脑价格: 19999.0
  }
}
```
</details>

<details>
<summary>例题: 有参数构造函数调用<br/>
</summary>

``` java
class Cat {
  public String color;
  private int age;

  public Cat() {
  }

  public Cat(String initColor, int initAge) {
    color = initColor;
    age = initAge;
  }

  public void showInfo() {
    System.out.println("猫的颜色: " + color + ", 年龄: " + age);
  }
}
public class ConstructorWithArgsTest {
  public static void main(String[] args) {
    Cat cat = new Cat();
    cat.showInfo(); // 猫的颜色: null, 年龄: 0

    cat = new Cat("白色", 10);
    cat.showInfo(); // 猫的颜色: 白色, 年龄: 10
  }
}
```
</details>

## 方法重载(Overload)
* 方法名相同，参数列表不同(参数个数，参数类型，参数顺序)
* 参数列表相同，返回值类型不一致，不算方法重载
* 参数类型相同，但是名字不同也不能算重载

<details>
<summary>例题: 函数重载<br/>
</summary>

``` java
class Sum {
  public int sum(int a, int b) {
    return a + b;
  }

  public int sum(int a, int b, int c) {
    return a + b + c;
  }

  public int sum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public double sum(double[] nums) {
    double sum = 0;
    for (double num : nums) {
      sum += num;
    }
    return sum;
  }
}
public class FunctionOverloadTest {
  public static void main(String[] args) {
    Sum sum = new Sum();
    System.out.println(sum.sum(1, 2)); // 3
    System.out.println(sum.sum(1, 2, 3)); // 6
    System.out.println(sum.sum(new int[]{1, 2, 3, 4})); // 10
    System.out.println(sum.sum(new double[]{1.0, 3.0, 5.0})); // 9.0
  }
}
```
</details>

## `this` 关键词
* 当前类对象的引用
* 构造方法和成员方法中访问成员变量时，默认会在成员变量之前加上 `this` 关键词 
``` java
public class ThisTest {
  public ThisTest() {
    System.out.println("Test:" + this);
  }
  public void test() {
    System.out.println("test:" + this);
  }
  public static void main(String[] args) {
    ThisTest test = new ThisTest();
    System.out.println(test);
    test.test();
  }
}
```

<details>
<summary>例题: this 关键词在构造方法和成员方法中的使用<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setAge(int age) {
    this.age = age;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.show();

    people = new People("Jack", 25);
    people.show();
  }
}
```
</details>

<details>
<summary>例题: this 实现链式编程<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People setName(String name) {
    this.name = name;
    return this;
  }

  public People setAge(int age) {
    this.age = age;
    return this;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People().setName("杜远超").setAge(25).show();
  }
}
```
</details>

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {
    this("杜远超", 25);
  }

  public People(String name) {
    this(name, 25);
  }

  public People(int age) {
    this("杜远超", age);
  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People("杜远超", 25).show();
    new People("杜远超").show();
    new People(25).show();
    new People().show();
  }
}
```
</details>

调用方法时候注意，必须注意引用对象是否初始化，如果未初始化，则会抛空指针异常

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class NullPointerExceptionTest {
  public static void main(String[] args) {
    People people = null;
    people.show();
  }
}
```
</details>

<details>
<summary>例题: 计算任意数字及以下的所有数字的阶乘结果并打印<br/>
</summary>

``` java
public class FactorialTest {
  public int factorial(int number) {
    int factorial = 1;
    for (int i = 1; i <= number; ++i) {
      factorial *= i;
    }
    return factorial;
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialTest factorialTest = new FactorialTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

## 递归函数
* 函数自身调用自身的过程
* 递归函数必须有递归出口，否则为无限递归，会出现栈溢出
* 递归可以可以是一个大的问题简单化
* 递归会无限分配栈空间，性能不佳


<details>
<summary>例题: 递归计算阶乘<br/>
</summary>

``` java
public class FactorialRecursionTest {
  public int factorial(int number) {
    return number == 1 || number == 0 ? 1 : number * factorial(number - 1);
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialRecursionTest factorialTest = new FactorialRecursionTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

<details>
<summary>例题: 递归实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    return n == 1 || n == 2 ? 1 : fib(n - 1) + fib(n - 2);
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

<details>
<summary>例题: 迭代实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    int first = 1;
    int second = 1;
    for (int i = 3; i <= n; ++i) {
      int temp = first + second;
      first = second;
      second = temp;
    }
    return second;
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

## 封装
* 对成员属性进行封装，防止非法赋值，赋值前进行合法性检测
* 使用关键词 `private` 私有化成员属性
* 对外提供 `public` 的方法访问私有成员

<details>
<summary>例题: 对象的getter、setter 方法 <br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {
    
  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }
  
  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public static void main(String[] args) {
    Student student = new Student();
    student.setName("杜远超");
    student.setAge(25);
    student.show();
  }
}
```
</details>

<details>
<summary>例题: 录入若干学生信息，并且输出<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {

  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public void input(Student[] students) {
    Scanner scanner = new Scanner(System.in);
    for (int i = 0; i < students.length; ++i) {
      System.out.print("请输入第" + (i + 1) + "学生信息(姓名 年龄): ");
      students[i] = new Student(scanner.next(), scanner.nextInt());
    }
  }

  public void output(Student[] students) {
    System.out.println("学生信息如下");
    System.out.println("姓名\t年龄");
    for (Student student : students) {
      System.out.println(student.getName() + "\t" + student.getAge());
    }
  }

  public   void main(String[] args) {
    System.out.print("请输入学生的人数: ");
    int len = new Scanner(System.in).nextInt();
    Student[] students = new Student[len];

    Student student = new Student();
    student.input(students);
    student.output(students);
  }
}
```
</details>


<details>
<summary>例题: 声明两个Student对象，打印信息<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student(String name, int age) {
    setName(name);
    setAge(age);
  }

  public Student() {
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
      return;
    }
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("非法年龄: " + age);
      return;
    }
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + getName() + ", age = " + getAge());
  }
  public static void main(String[] args) {
    Student stu1 = new Student("Jack", 25);
    Student stu2 = new Student("杜远超", 26);
    stu1.show();
    stu2.show();
  }
}
```
</details>

## static 关键字
* 表示的成员属性或者方法为所有对象共享
* 随着类的加载而初始化，和对象创建与否无关
* 非静态成员方法中可以访问静态和非静态成员
* 静态成员的访问推荐使用类名访问，而不是引用
* 静态成员方法中只能访问静态变量，不能访问非静态成员

<details>
<summary>例题: static统计一个对象被创建了多少次<br/>
</summary>

``` java
public class StaticTest {
  private static int count = 0;

  public StaticTest() {
    count++;
  }
  public static int getCount() {
    return count;
  }

  public static void main(String[] args) {
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了0次
    StaticTest staticTest = new StaticTest();
    StaticTest staticTest1 = new StaticTest();
    StaticTest staticTest2 = new StaticTest();
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了3次
  }
}
```
</details>

<details>
<summary>例题: 打印 main 函数的参数<br/>
</summary>

``` java
public class PrintMainArgs {
  public static void main(String[] args) {
    System.out.println("main方法的参数长度为:" + args.length);
    System.out.println("参数列表为:" + Arrays.toString(args));
  }
}
```
</details>

<details>
<summary>例题: 编写代码实现单例设计模式(Singleton)(饿汉式)<br/>
</summary>

``` java
class Singleton {
  private static final Singleton singleton = new Singleton();
  private Singleton() {

  }

  public static Singleton getInstance() {
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2); // true
}
```
</details>


<details>
<summary>例题: 编写代码实现单例设计模式(Singleton) - 懒汉式(存在线程安全问题，后面解决)<br/>
</summary>

``` java
class Singleton {
  private static Singleton singleton;
  private Singleton() {

  }

  public static Singleton getInstance() {
    if (singleton == null) {
      singleton = new Singleton();
    }
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2);
  }
}
```
</details>

## 继承
* 抽取各个类的共同属性，减少代码的冗余
* 提高代码的复用性，可维护性，扩展性
* 使用关键词 `extends` 实现继承
* 构造方法不能继承
* 私有方法不能继承
* 子类和父类必须是 `is-a` 关系
* 不支持多继承


<details>
<summary>例题: 实现学生类继承人物类<br/>
</summary>

``` java
class People {
  public String name;
  public int age;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}

class Student extends People {
  private int score;

  public Student(String name, int age, int score) {
    setName(name);
    setAge(age);
    this.score = score;
  }

  public void setScore(int score) {
    this.score = score;
  }

  public int getScore() {
    return score;
  }
}
public class ExtendsTest {
  public static void main(String[] args) {
    Student student = new Student("杜远超", 25, 99);
    student.show(); // name = 杜远超, age = 25
    System.out.println("学生" + student.getName() + "的成绩是" + student.getScore()); // 学生杜远超的成绩是99
  }
}
```
</details>

## 重写(Override)
* 重写从父类继承的方法
* 使用 `super` 关键词访问父类的方法或者成员
* 使用注解`@Verride` 可以标注某个方法为重写方法

<details>
<summary>例题: 重写父类继承而来的方法<br/>
</summary>

``` java
class People {
  public String name;
  public int age;

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}

class Student extends People {
  private int score;

  public Student(String name, int age, int score) {
    super(name, age);
    this.score = score;
  }

  public void setScore(int score) {
    this.score = score;
  }

  public int getScore() {
    return score;
  }

  @Override
  public void show() {
    super.show();
    System.out.println("score = " + score);
  }
}
public class OverrideTest {
  public static void main(String[] args) {
    Student student = new Student("杜远超", 25, 99);
    student.show();
  }
}
```
</details>

## 访问修饰符
* public
* protected
* default
* private

## 包(package)
* 方便管理类
* package 语句必须出现在源代码最前面一行
* 解决类名冲突，方便项目的管理

## 导入import
* 可以在程序中导入jdk，以及其他人编写好的类供本程序的使用
* import static xxx 可以实现静态导入

## 代码块，静态代码块，构造方法的执行顺序
1. 静态代码块
2. 非静态代码块
3. 构造方法

<details>
<summary>例题: 代码块，静态代码块和构造方法的执行顺序<br/>
</summary>

``` java
class MyClass {
  {
    System.out.println("非静态代码块"); // 2
  }
  static {
    System.out.println("静态代码"); // 1
  }
  public MyClass() {
    System.out.println("构造函数"); // 3
  }
}
public class CodeBlockExecuteOrderTest {
  public static void main(String[] args) {
    MyClass myClass = new MyClass();
  }
}
```
</details>

<details>
<summary>例题: 继承关系中代码块，静态代码块和构造方法的执行顺序<br/>
</summary>

``` java
class SuperClass {
  {
    System.out.println("父类的非静态代码块"); // 3
  }
  static {
    System.out.println("父类的静态代码块"); // 1
  }
  public SuperClass() {
    System.out.println("父类构造方法"); // 4
  }
}
class SubClass extends SuperClass{
  {
    System.out.println("子类的非静态代码块"); // 5
  }
  static {
    System.out.println("子类的静态代码块"); // 2
  }
  public SubClass() {
    System.out.println("子类的构造方法"); // 6
  }
}
public class CodeBlockExecuteOrderTest {
  public static void main(String[] args) {
    SubClass subClass = new SubClass();
  }
}
```
</details>

## final 关键词
* final 定义常量，表示不能重新赋值
* final 修饰类表示类不能被继承
* final 修饰方法表示子类不能重写此方法
* final 修饰成员变量必须初始化，或者在代码块，构造方法中初始化，常量均采用大写字母格式，多个单词之间使用 `_` 分隔开
* final 修饰引用变量，表示变量不能重新指向其他对象，但是可以修改指向的对象内容

## 多态
* 父类引用指向子类对象
* 父类引用不可以直接调用子类独有的方法
* 对于父类和子类都存在的方法，编译阶段调用的是父类的方法，运行阶段调用的是子类的方法 (非静态方法)
* 父类引用想调用子类对象独有方法，需要显示转换为子类对象


<details>
<summary>例题: 多态演示<br/>
</summary>

``` java
class Shape {
  private int x;
  private int y;

  public Shape(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public int getX() {
    return x;
  }

  public void setX(int x) {
    this.x = x;
  }

  public int getY() {
    return y;
  }

  public void setY(int y) {
    this.y = y;
  }

  void show() {
    System.out.println("x = " + x + ", y = " + y);
  }
}

class Circle extends Shape {
  private int radius;
  public Circle(int x, int y, int radius) {
    super(x, y);
    this.radius = radius;
  }

  @Override
  void show() {
    System.out.println("x = " + getX() + ", y = " + getY() + ", r = " + radius);
  }

  public double area() {
    return Math.PI * radius * radius;
  }
}
public class PolymorphismTest {
  public static void main(String[] args) {
    Shape shape = new Circle(0, 0, 10);
    shape.show(); // x = 0, y = 0, r = 10
    System.out.println("area = " + ((Circle)shape).area());
  }
}
```
</details>

## instanceof 的使用

<details>
<summary>例题: instanceof<br/>
</summary>

``` java
class Shape {

}
class Circle extends Shape{

}

class Rectangle extends Shape{

}
public class InstanceofTest {
  public static void main(String[] args) {
    Shape shape = new Circle();
    Circle circle;
    if (shape instanceof Circle) {
      circle = (Circle) shape;
    }
  }
}
```
</details>

<details>
<summary>例题: 多态的应用<br/>
</summary>

``` java
class Shape {
  public void draw() {
    System.out.println("绘制图形");
  }
}
class Circle extends Shape{

  @Override
  public void draw() {
    System.out.println("绘制圆形");
  }
}

class Rectangle extends Shape{
  @Override
  public void draw() {
    System.out.println("绘制长方形");
  }
}
class Line extends Shape {
  @Override
  public void draw() {
    System.out.println("绘制线条");
  }
}

public class PolymorphismTest {
  public static void draw(Shape shape) {
    shape.draw();
  }
  public static void main(String[] args) {
    PolymorphismTest.draw(new Circle()); // 绘制圆形
    PolymorphismTest.draw(new Rectangle()); // 绘制长方形
    PolymorphismTest.draw(new Line()); // 绘制线条
  }
}
```
</details>

## 抽象类
* 使用关键词 `abstract` 声明抽象类和抽象方法
* 抽象类可以有成员变量，成员方法，构造方法
* 不能被实例化
* 抽象类中可以没有抽象方法
* 抽象类主要用于子类的继承
* 子类继承抽象类时，必须实现抽象的抽象方法，不然子类也得是抽象类

## 接口
* 比抽象类还抽象
* 使用关键词 `interface` 声明接口
* 接口中的成员变量默认是 `public static final`
* Java 9以后，接口中可以声明 `private` 方法，并且有默认的实现
* 使用关键词 `implements` 实现接口
* 接口支持多继承可以实现多个接口，而类不支持多继承

<details>
<summary>例题: 接口案例<br/>
</summary>

``` java
interface USB {
  void connect();
}
interface Power {
  void charging();
}

class Computer implements USB, Power {

  @Override
  public void connect() {
    System.out.println("链接手机");
  }

  @Override
  public void charging() {
    System.out.println("充电");
  }
}
public class InterfaceTest {
  public static void main(String[] args) {
    Computer computer = new Computer();
    computer.connect();
    computer.charging();
  }
}
```
</details>

## 抽象类和接口的区别
* 抽象类使用关键词 `abstract`，接口使用 `interface`
* 继承抽象类使用关键词 `extends`，实现接口使用 `implements`
* 只能继承一个抽象类，但是可以实现多个接口
* 抽象类可以有构造方法，但是接口中不可以
* 抽象类中可以有成员变量，但是接口中的成员变量默认是 `public static final`
* 抽象类中可以有成员方法，接口中不可以，新版jdk中可以有私有成员方法(java 9)
* 接口中可以使用 `default` 关键词声明默认实现的函数，子类可以决定是否重写

## 内部类

<details>
<summary>例题: 成员内部类<br/>
</summary>

``` java
class OuterClass {
  private int number = 10;
  class InnerClass {
    private int number;

    public InnerClass(int number) {
      this.number = number;
    }
    public void print() {
      System.out.println("内部类的值为: " + this.number);
      System.out.println("外部类的值为: " + OuterClass.this.number);
    }
  }
}
public class MemberInnerClassTest {
  public static void main(String[] args) {
    OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(100);
    innerClass.print();
  }
}
```
</details>

<details>
<summary>例题: 静态内部类<br/>
</summary>

``` java
class OuterClass {
  private static int count = 10;
  public static class InnerClass {
    private static int count;

    public InnerClass(int count) {
      InnerClass.count = count;
    }

    public void show() {
      System.out.println("外部类的值: " + OuterClass.count);
      System.out.println("内部类的值: " + count);
    }
  }
}
public class StaticInnerClassTest {
  public static void main(String[] args) {
    OuterClass.InnerClass innerClass = new OuterClass.InnerClass(100);
    innerClass.show();
  }
}
```
</details>

<details>
<summary>例题: 方法内部类<br/>
</summary>

``` java
public class FunctionInnerClassTest {
  public static void main(String[] args) {
    class People {
      private String name;
      private int age;

      public People(String name, int age) {
        this.name = name;
        this.age = age;
      }

      public String getName() {
        return name;
      }

      public void setName(String name) {
        this.name = name;
      }

      public int getAge() {
        return age;
      }

      public void setAge(int age) {
        this.age = age;
      }

      @Override
      public String toString() {
        return "name = " + name + ", age = " + age;
      }
    }

    People people = new People("杜远超", 25);
    System.out.println(people);
  }
}
```
</details>

<details>
<summary>例题: 接口回调<br/>
</summary>

``` java
interface USB {
  void connect();
}

public class InterfaceCallback {
  public void connectToUSB(USB usb) {
    usb.connect();
  }

  public static void main(String[] args) {
    InterfaceCallback interfaceCallback = new InterfaceCallback();
    interfaceCallback.connectToUSB(new USB() {
      @Override
      public void connect() {
        System.out.println("正在链接USB传送文件...");
      }
    });
  }
}
```
</details>

## 枚举enum
<details>
<summary>例题: 颜色枚举类<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }

  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum whiteColor = ColorEnum.WHITE;
    ColorEnum blueColor = ColorEnum.BLUE;
    System.out.println(whiteColor.getColorDesc());
    System.out.println(blueColor.getColorDesc());
  }
}
```
</details>


<details>
<summary>例题: switch中使用枚举<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }

  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum blackColor = ColorEnum.BLUE;
    switch (blackColor) {
      case BLUE -> System.out.println("蓝色");
      case WHITE -> System.out.println("白色");
      case BLACK -> System.out.println("黑色");
      case RED -> System.out.println("红色");
    }
  }
}
```
</details>

<details>
<summary>例题: 枚举常用内置方法<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }
  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum[] colorEnums = ColorEnum.values();
    for (ColorEnum colorEnum : colorEnums) {
      System.out.println(colorEnum.ordinal() + ":" + colorEnum);
    }

    System.out.println(ColorEnum.valueOf("WHITE").getColorDesc());
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.RED));
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.WHITE));
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.BLUE));
  }
}
```
</details>

<details>
<summary>例题: 枚举实现接口<br/>
</summary>

``` java
interface MyInterface {
  void print();
}
enum ColorEnum implements MyInterface{
  RED("红色") {
    @Override
    public void print() {
      System.out.println("我是红色");
    }
  }, WHITE("白色") {
    @Override
    public void print() {
      System.out.println("我是白色");
    }
  };
  private final String colorDesc;

  ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }
  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum whiteColor = ColorEnum.WHITE;
    whiteColor.print(); // 我是白色
  }
}
```
</details>


## 注解
使用关键词 `@interface` 定义注解
<details>
<summary>例题: 注解的定义<br/>
</summary>

``` java
@interface MyAnnotation {
  String value();
  String name();
}

public class AnnotationTest {

  @MyAnnotation(name = "name", value = "value")
  public static void test() {
    System.out.println("test annotation");
  }
  public static void main(String[] args) {
    AnnotationTest.test();
  }
}
```
</details>

## 元注解
注解在自定义注解上的注解

* `@Retention(value = RetentionPolicy.SOURCE)` 只在源代码保留，编译后丢失
* `@Retention(value = RetentionPolicy.CLASS)` 在字节码阶段有效
* `@Retention(value = RetentionPolicy.RUNTIME)` 运行阶段有效，可以通过反射获取注解内容
* `@Documented` 注解的注解，在使用 `javadoc` 生成 `api` 时候会提取注解
* `@Target` 注解用于标记特定的注解被使用的场合，如 `@Target({ElementType.FIELD, ElementType.CONSTRUCTOR})` 只能注解成员变量和构造方法
* `@Inherited` 表示该注解可以被子类继承
* `@Repeatable()`

## Object equals 方法
* equals 方法默认比较对象的地址是否一致
* 如果想要比较对象的内容，需要重写对象的equals方法

<details>
<summary>例题: 对象未重写equals方法<br/>
</summary>

``` java
Student stu1 = new Student(10001, "duyuanchao");
Student stu2 = new Student(10001, "duyuanchao");
System.out.println(stu1 == stu2); // false
System.out.println(stu1.equals(stu2)); // false
```
</details>

<details>
<summary>例题: 对象重写equals方法<br/>
</summary>

``` java
class People {
  private String name;
  private int age;

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    People people = (People) o;
    return age == people.age && Objects.equals(name, people.name);
  }

  @Override
  public int hashCode() {
    return 0;
  }
}
People p1 = new People("duyuanchao", 25);
People p2 = new People("duyuanchao", 25);
People p3 = new People("jack", 25);
System.out.println(p1 == p2); // false
System.out.println(p1.equals(p2)); // true
System.out.println(p1.equals(p3)); // false
```
</details>

## hashCode 方法

<details>
<summary>例题: 重写 hashCode 方法<br/>
</summary>

``` java
class People {
  private final String name;
  private final int age;

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    People people = (People) o;
    return age == people.age && Objects.equals(name, people.name);
  }

  @Override
  public int hashCode() {
    return this.age % 13;
  }
}
People p1 = new People("duyuanchao", 25);
People p2 = new People("duyuanchao", 25);
assertEquals(p1.hashCode(), p2.hashCode());
```
</details>

## Object toString 方法
* 默认打印 `类全名@hashCode`

<details>
<summary>例题: 重写 toString 方法<br/>
</summary>

``` java
class People {
  private final String name;
  private final int age;

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  @Override
  public String toString() {
    return "name = " + name + ", age = " + age;
  }
}

People people = new People("duyuanchao", 25); // name = duyuanchao, age = 25
```
</details>

## Integer 包装类
基本数据类型都有对应的包装类，很方便的把基本数据类型包装成对象类型

`Integer` 包装类

<details>
<summary>例题: valueOf 方法<br/>
</summary>

``` java
Integer integer = Integer.valueOf(100);
System.out.println(integer); // 100

integer = Integer.valueOf("123");
System.out.println(integer); // 123

integer = Integer.valueOf("a", 16);
System.out.println(integer); // 10
```
</details>

<details>
<summary>例题: parseInt 方法<br/>
</summary>

``` java
int number = Integer.parseInt("123");
System.out.println(number); // 123
```
</details>

注意，从jdk5开始，-128 - 127 之间的数字在自动装箱过程中有缓存
<details>
<summary>例题: 自动装箱方法<br/>
</summary>

``` java
Integer integer = 10;
Integer integer1 = 10;
System.out.printf(integer == integer1); // true

Integer first = 128;
Integer second = 128;
System.out.println(first == second); // false
```
</details>

<details>
<summary>例题: 进制转换<br/>
</summary>

``` java
System.out.println(Integer.toBinaryString(10)); // 1010
System.out.println(Integer.toOctalString(10)); // 12
System.out.println(Integer.toHexString(10)); // a
```
</details>


## Double 包装类

<details>
<summary>例题: Double 常用方法<br/>
</summary>

``` java
Double d = Double.valueOf(3.14);
System.out.println(d.doubleValue()); // 3.14

d = Double.valueOf("3.14159");
System.out.println(d.doubleValue()); // 3.14159

d = 0.0 / 0;
System.out.println(d); // NaN
```
</details>

<details>
<summary>例题: 自动装箱和拆箱<br/>
</summary>

``` java
Double d = 3.14;
System.out.println(d.doubleValue()); // 3.14
double pi = d;
System.out.println(pi); // 3.14
```
</details>

## Boolean 包装类
<details>
<summary>例题: Boolean 常用方法<br/>
</summary>

``` java
Boolean b = Boolean.valueOf(true);
System.out.println(b.booleanValue()); // true

b = Boolean.valueOf("false");
System.out.println(b.booleanValue()); // false
```
</details>

<details>
<summary>例题: 自动装箱和自动拆箱<br/>
</summary>

``` java
Boolean b = false;
System.out.println(b); // false

boolean bValue = b;
System.out.println(bValue); // false
```
</details>

## Character 包装类
<details>
<summary>例题: valueOf 使用<br/>
</summary>

``` java
Character c = Character.valueOf('A');
System.out.println(c); // A
```
</details>

<details>
<summary>例题: 自动拆箱和装箱<br/>
</summary>

``` java
Character c = 'A';
System.out.println(c); // A
```
</details>

<details>
<summary>例题: 常用方法<br/>
</summary>

``` java
System.out.println(Character.isLowerCase('A')); // false
System.out.println(Character.isLowerCase('a')); // true
System.out.println(Character.isLowerCase('1')); // false

System.out.println(Character.isUpperCase('A')); // true
System.out.println(Character.isUpperCase('a')); // false
System.out.println(Character.isUpperCase('1')); // false

System.out.println(Character.isDigit('A')); // false
System.out.println(Character.isDigit('a')); // false
System.out.println(Character.isDigit('1')); // true

System.out.println(Character.toLowerCase('A')); // a
System.out.println(Character.toUpperCase('a')); // A

System.out.println(Character.getNumericValue('8')); // 8
System.out.println(Character.getNumericValue('A')); // 10
System.out.println(Character.getNumericValue('a')); // 10
```
</details>

## Math 类
<details>
<summary>例题: 常用方法<br/>
</summary>

``` java
Math.max(1, 3); // 3
Math.max(-1.5, -3.27); // -1.5
Math.min(1, 3); // 1
Math.min(-1.5, -3.27); // -3.27
Math.pow(2, 10); // 1024
Math.abs(-10); // 10
Math.round(3.14); // 3
Math.round(3.78); // 4
Math.round(-3.14); // -3
double num = Math.random(); // num >= 0 && num < 1
Math.sqrt(4); // 2
Math.sqrt(2); // 1.4142135623730951
```
</details>

## BigDecimal 类
<details>
<summary>例题: 常用方法<br/>
</summary>

``` java
BigDecimal bd = new BigDecimal("123456.789");
assertEquals("246913.578", bd.add(bd).toString());
assertEquals("0.000", bd.subtract(bd).toString());
assertEquals("15241578750.190521", bd.multiply(bd).toString());
assertEquals("1.000", bd.divide(bd, RoundingMode.HALF_UP).toString());
assertEquals("24691.358", bd.divide(new BigDecimal("5.0"), RoundingMode.HALF_UP).toString());
```
</details>

## BigInteger 类
<details>
<summary>例题: 常用方法<br/>
</summary>

``` java
BigInteger bigInteger = new BigInteger("1234567891011121314151617181920");
assertEquals("1234567891011121314151617181920", bigInteger.toString());

BigInteger i1 = new BigInteger("1234567891011121314151617181920");
BigInteger i2 = new BigInteger("1234567891011121314151617181920");
assertEquals("2469135782022242628303234363840", i1.add(i2).toString());

BigInteger bigInteger = new BigInteger("123456789");
assertEquals("1881676371789154860897069", bigInteger.pow(3).toString());
bigInteger = new BigInteger("1234567891011121314151617181920");
assertEquals(
    "1881676376412480405375011631213584661038332261704414240874801542371684441105634548133888000",
    bigInteger.pow(3).toString());
```
</details>

## 可变字符串 StringBuilder

<details>
<summary>例题: 构造 StringBuilder 对象<br/>
</summary>

``` java
StringBuilder sb = new StringBuilder("something");
```
</details>

<details>
<summary>例题: toString 方法 <br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("hello123");
assertEquals("hello123", builder.toString());
```
</details>

<details>
<summary>例题: capacity 方法<br/>
</summary>

``` java
StringBuilder sb = new StringBuilder();
sb.capacity(); // 16

sb = new StringBuilder(20);
sb.capacity(); // 20

sb = new StringBuilder("abc123");
sb.capacity(); // 22
```
</details>

<details>
<summary>例题:  insert 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("abc");
builder.insert(0, "123");
assertEquals("123abc", builder.toString());
builder.insert(3, "45");
assertEquals("12345abc", builder.toString());
builder.insert(builder.length(), "!");
assertEquals("12345abc!", builder.toString());
```
</details>

<details>
<summary>例题: append 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder();
builder.append("Hello").append(",").append("World").append("!");
assertEquals("Hello,World!", builder.toString());
```
</details>

<details>
<summary>例题: deleteCharAt 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("hello123abc");
builder.deleteCharAt(0);
assertEquals("ello123abc", builder.toString());

//delete ello
for (int i = 1; i <= 4; i++) {
  builder.deleteCharAt(0);
}
assertEquals("123abc", builder.toString());
builder.deleteCharAt(builder.length() - 1);
assertEquals("123ab", builder.toString());
```
</details>


<details>
<summary>例题: delete 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("123abcABC");
builder.delete(0, 3); // delete "123"
assertEquals("abcABC", builder.toString());
builder.delete(3, builder.length()); // delete "ABC"
assertEquals("abc", builder.toString());
```
</details>

<details>
<summary>例题: charAt 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("0123456789abc");
assertEquals('a', builder.charAt(10));

for (int i = 0; i <= 9; ++i) {
  assertEquals('0' + i, builder.charAt(i));
}
```
</details>

<details>
<summary>例题: setCharAt 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("0123456789abc");
assertEquals('a', builder.charAt(10));

for (int i = 0; i <= 9; ++i) {
  assertEquals('0' + i, builder.charAt(i));
}
```
</details>

<details>
<summary>例题: replace 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("abc123");
builder.replace(0, 3, "ABC");
assertEquals("ABC123", builder.toString());
```
</details>

<details>
<summary>例题: indexOf 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("abc123abc");
assertEquals(1, builder.indexOf("bc"));
assertEquals(7, builder.indexOf("bc", 3));
```
</details>

<details>
<summary>例题: lastIndexOf 方法<br/>
</summary>

``` java
StringBuilder builder = new StringBuilder("abc123abc");
assertEquals(7, builder.lastIndexOf("bc"));
assertEquals(6, builder.lastIndexOf("abc", 6));
```
</details>

面试题
* 为什么 `StringBuilder` 要返回对象本身

  答: 因为这样子可以实现链式调用

* `StringBuilder` 和 `String` 如何实现转换

  答: 分别调用 `toString` 方法，以及构造方法构造 `StringBuilder`

* `String`、`StringBuffer`、`StringBuilder` 的效率
  
  答: `String` < `StringBuffer` < `StringBuilder`

## Date 时间类

<details>
<summary>例题: 构造方法<br/>
</summary>

``` java
Date firstDate = new Date();
Date secondDate = new Date(System.currentTimeMillis());
assertEquals(firstDate, secondDate);
```
</details>

<details>
<summary>例题: getTime 方法<br/>
</summary>

``` java
Date date = new Date(1636200610202L);
assertEquals(1636200610202L, date.getTime());
```
</details>

<details>
<summary>例题: setTime 方法<br/>
</summary>

``` java
long time = System.currentTimeMillis();
Date date = new Date(time);
assertEquals(time, date.getTime());
```
</details>

## SimpleDateFormat 时间格式化工具类

<details>
<summary>例题: format 方法<br/>
</summary>

``` java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
long time = 1636201275057L;
Date date = new Date(time);
String formatDate = format.format(date);
assertEquals("2021-11-06 20:21:15", formatDate);
```
</details>

## Calendar 日历类
<details>
<summary>例题: calendar 初始化<br/>
</summary>

``` java
Calendar calendar = Calendar.getInstance();
calendar.set(2099, Calendar.DECEMBER, 31, 23, 59, 59);
assertEquals("2099-12-31 23:59:59",
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calendar.getTime()));
```
</details>


<details>
<summary>例题: calendar基本使用方法<br/>
</summary>

``` java
Calendar calendar = Calendar.getInstance();
calendar.clear();
calendar.set(Calendar.YEAR, 2088);
calendar.set(Calendar.MONTH, 8);
calendar.set(Calendar.DATE, 25);
calendar.set(Calendar.HOUR_OF_DAY, 16);
calendar.set(Calendar.MINUTE, 33);
calendar.set(Calendar.SECOND, 59);

assertEquals("2088-09-25 16:33:59",
        new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(calendar.getTime()));
```
</details>

## Java 8 提供的时间类使用

<details>
<summary>例题: LocalDate、LocalTime、LocalDateTime 初始化<br/>
</summary>

``` java
LocalDate localDate = LocalDate.now();
LocalTime localTime = LocalTime.now();
LocalDateTime localDateTime = LocalDateTime.now();
System.out.println("localDate: " + localDate);
System.out.println("localTime: " + localTime);
System.out.println("localDateTime: " + localDateTime);
```
</details>

<details>
<summary>例题: LocalDate、LocalTime、LocalDateTime of 方法使用<br/>
</summary>

``` java
LocalDate localDate = LocalDate.of(2019, 11, 30);
LocalTime localTime = LocalTime.of(15, 16, 17);
LocalDateTime localDateTime = LocalDateTime.of(2019, 11, 30, 15, 16, 17);

assertEquals(2019, localDate.getYear());
assertEquals(11, localDate.getMonth().getValue());
assertEquals(30, localDate.getDayOfMonth());

assertEquals(15, localTime.getHour());
assertEquals(16, localTime.getMinute());
assertEquals(17, localTime.getSecond());

assertEquals(2019, localDateTime.getYear());
assertEquals(11, localDateTime.getMonthValue());
assertEquals(30, localDateTime.getDayOfMonth());
assertEquals(15, localDateTime.getHour());
assertEquals(16, localDateTime.getMinute());
assertEquals(17, localDateTime.getSecond());
```
</details>

## DateTimeFormatter 格式化时间类
<details>
<summary>例题: DateTimeFormatter 类使用<br/>
</summary>

``` java
LocalDateTime localDateTime = LocalDateTime.of(2099, Month.DECEMBER, 30, 23, 59, 59);
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
assertEquals("2099-12-30 23:59:59", formatter.format(localDateTime));
```
</details>


