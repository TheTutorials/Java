# 面向对象
* Java 中一切皆对象

## 类的定义
``` java
访问修饰符 class 类名 {
    成员属性和方法定义...
}
```
如
``` java
class Person {
  String name = "Java";
  public void sayHi() {
    System.out.println(name);
  }
}
```

## 类的初始化
* 类是创建对象的模版（蓝图）
* 使用关键词 `new` 创建类对应的实体
* 使用关键词 `new` 创建的对象存储在堆空间里
* 成员变量可以不初始化，有默认值
``` java
class Person {
  String name;
  int age;
}

new Person(); //匿名对象
Person jack = new Person(); //创建对象并保存对象的引用
```

## 访问对象成员
``` java
public class Student {
  String name; //学生姓名
  int age; //学生年龄

  public static void main(String[] args) {
    Student jack = new Student();
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:null，年龄是:0
    jack.name = "Jack"; // 修改姓名
    jack.age = 25; // 修改年龄
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:Jack，年龄是:25

    Student tom = new Student();
    tom.name = "Tom";
    tom.age = 20;
    System.out.println("学生的名字:" + tom.name + "，年龄是:" + tom.age); // 学生的名字:Tom，年龄是:20
  }
}
```

<details>
<summary>例题: 定义一个Point对象表示点<br/>
</summary>

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    System.out.println("x = " + point.x + ", y = " + point.x);
  }
}
```
</details>

## 方法的定义
``` java
[访问修饰符] 返回值类型 函数名(参数列表) {
  函数体
} 
```

* 访问修饰符: `public` `private` `protect` `default`
* 返回值类型: 8大基本数据类型以及引用类型都可以作为返回值类型，如果不需要返回值，声明为 `void`
* 函数名: 遵循变量命名规则
* 参数列表: 声明函数所需要接受的参数，从主调函数传递而来，如果不需要传递任何参数可以直接空着
* 函数题: 根据参数列表执行相应的运算，然后返回运算结果（如果需要)

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public void show() {
    System.out.println("x = " + x + ", y = " + x);
  }

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    point.show();
  }
}
```

## 方法的调用
* 函数名(实际参数)
* 实际参数传递给形式参数用于初始化形式参数
* 实参列表和形参数列表必须保持类型和数量一致
* 实际参数可以传递常量、变量、表达式、方法调用等

<details>
<summary>例题: 定义由参数成员函数修改成员属性值<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄
  double height; //身高

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public void setHeight(double newHeight) {
    height = newHeight;
  }

  public void setInfo(String newName, int newAge, double newHeight) {
    name = newName;
    age = newAge;
    height = newHeight;
  }

  public void showInfo() {
    System.out.println("姓名:" + name + "\t年龄:" + age + "\t身高:" + height);
  }
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.setHeight(2.0);
    people.showInfo();

    People jack = new People();
    jack.setInfo("Jack", 22, 2.21);
    jack.showInfo();
  }
}
```
</details>

## 可变长参数函数定义
* 参数的数量根据实际情况而决定
* 可以是0个或者多个
* 一个方法只允许有一个可变参数，并且只能位于最后一个位置

<details>
<summary>例题: 可变参数求任意个数字求和<br/>
</summary>

``` java
public class VarParametersTest {
  public int sum(int... nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public static void main(String[] args) {
    VarParametersTest varParametersTest = new VarParametersTest();
    System.out.println(varParametersTest.sum()); // 0
    System.out.println(varParametersTest.sum(1)); // 1
    System.out.println(varParametersTest.sum(1, 2)); // 3
    System.out.println(varParametersTest.sum(1, 2, 3)); // 5
    int[] nums = {1, 2, 3, 4, 5};
    System.out.println(varParametersTest.sum(nums)); // 15
  }
}
```
</details>

<details>
<summary>例题: 无参数有返回值案例<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);

    String returnName = people.getName();
    int returnAge = people.getAge();
    System.out.println(returnName);
    System.out.println(returnAge);
  }
}
```
</details>

注意: 
* 形式参数的改变不会影响实际参数的改变，因为他们存在于不同的栈空间
* 传递引用参数时，形式参数通过引用改变内容，同时回修改实际参数的内容
* 形式参数改变引用指向时候，改变形式参数不会影响到实际参数
``` java
public class ChangeArgs {
  public void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("swap函数中的a = " + a + ", b = " + b); // swap函数中的a = 4, b = 3
  }

  public static void main(String[] args) {
    int a = 3;
    int b = 4;
    System.out.println("交换前: a = " + a + ", b = " + b); // 交换前: a = 3, b = 4
    new ChangeArgs().swap(a, b);
    System.out.println("交换后: a = " + a + ", b = " + b); // 交换后: a = 3, b = 4  
  }
}
```

``` java
public class ChangeArgs {
  public void swap(int[] nums) {
    int temp = nums[0];
    nums[0] = nums[1];
    nums[1] = temp;
  }

  public static void main(String[] args) {
    int[] nums = {3, 4};
    System.out.println("交换前:" + Arrays.toString(nums)); // 交换前:[3, 4]
    new ChangeArgs().swap(nums);
    System.out.println("交换后:" + Arrays.toString(nums)); // 交换后:[4, 3]
  }
}
```

## 方法调用内存结构
* 栈用于存放程序运行时的所有局部变量
* 每次的函数调用会在栈中开辟对应的空间，存储该方法的局部变量
* 方法返回时候，栈顶弹出，返回到上一个主调函数


## 构造方法
* 用于创建对象时，初始化成员属性
* 构造方法没有返回值
* 构造方法方法名和类名保持一致
* 构造方法只能使用 `new` 关键词调用
* 如果没有显示声明构造方法，系统默认添加一个无参数构造方法
* 如果已经定义了构造方法，系统不会默认提供无参构造方法，如果需要需要手动定义

<details>
<summary>例题: 无参数构造方法的调用<br/>
</summary>

``` java
class Computer {
  public String color;
  public double price;
  public Computer() {
    System.out.println("构造方法被调用了");
    color = "红色";
    price = 19999;
  }
  public void showComputerInfo() {
    System.out.println("电脑颜色: " + color + ", 电脑价格: " + price);
  }
}
public class ConstructorTest {
  public static void main(String[] args) {
    Computer computer = new Computer(); // 构造方法被调用了
    computer.showComputerInfo(); // 电脑颜色: 红色, 电脑价格: 19999.0
  }
}
```
</details>

<details>
<summary>例题: 有参数构造函数调用<br/>
</summary>

``` java
class Cat {
  public String color;
  private int age;

  public Cat() {
  }

  public Cat(String initColor, int initAge) {
    color = initColor;
    age = initAge;
  }

  public void showInfo() {
    System.out.println("猫的颜色: " + color + ", 年龄: " + age);
  }
}
public class ConstructorWithArgsTest {
  public static void main(String[] args) {
    Cat cat = new Cat();
    cat.showInfo(); // 猫的颜色: null, 年龄: 0

    cat = new Cat("白色", 10);
    cat.showInfo(); // 猫的颜色: 白色, 年龄: 10
  }
}
```
</details>

## 方法重载(Overload)
* 方法名相同，参数列表不同(参数个数，参数类型，参数顺序)
* 参数列表相同，返回值类型不一致，不算方法重载
* 参数类型相同，但是名字不同也不能算重载

<details>
<summary>例题: 函数重载<br/>
</summary>

``` java
class Sum {
  public int sum(int a, int b) {
    return a + b;
  }

  public int sum(int a, int b, int c) {
    return a + b + c;
  }

  public int sum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public double sum(double[] nums) {
    double sum = 0;
    for (double num : nums) {
      sum += num;
    }
    return sum;
  }
}
public class FunctionOverloadTest {
  public static void main(String[] args) {
    Sum sum = new Sum();
    System.out.println(sum.sum(1, 2)); // 3
    System.out.println(sum.sum(1, 2, 3)); // 6
    System.out.println(sum.sum(new int[]{1, 2, 3, 4})); // 10
    System.out.println(sum.sum(new double[]{1.0, 3.0, 5.0})); // 9.0
  }
}
```
</details>

## `this` 关键词
* 当前类对象的引用
* 构造方法和成员方法中访问成员变量时，默认会在成员变量之前加上 `this` 关键词 
``` java
public class ThisTest {
  public ThisTest() {
    System.out.println("Test:" + this);
  }
  public void test() {
    System.out.println("test:" + this);
  }
  public static void main(String[] args) {
    ThisTest test = new ThisTest();
    System.out.println(test);
    test.test();
  }
}
```

<details>
<summary>例题: this 关键词在构造方法和成员方法中的使用<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setAge(int age) {
    this.age = age;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.show();

    people = new People("Jack", 25);
    people.show();
  }
}
```
</details>

<details>
<summary>例题: this 实现链式编程<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People setName(String name) {
    this.name = name;
    return this;
  }

  public People setAge(int age) {
    this.age = age;
    return this;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People().setName("杜远超").setAge(25).show();
  }
}
```
</details>

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {
    this("杜远超", 25);
  }

  public People(String name) {
    this(name, 25);
  }

  public People(int age) {
    this("杜远超", age);
  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People("杜远超", 25).show();
    new People("杜远超").show();
    new People(25).show();
    new People().show();
  }
}
```
</details>

调用方法时候注意，必须注意引用对象是否初始化，如果未初始化，则会抛空指针异常

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class NullPointerExceptionTest {
  public static void main(String[] args) {
    People people = null;
    people.show();
  }
}
```
</details>

<details>
<summary>例题: 计算任意数字及以下的所有数字的阶乘结果并打印<br/>
</summary>

``` java
public class FactorialTest {
  public int factorial(int number) {
    int factorial = 1;
    for (int i = 1; i <= number; ++i) {
      factorial *= i;
    }
    return factorial;
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialTest factorialTest = new FactorialTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

## 递归函数
* 函数自身调用自身的过程
* 递归函数必须有递归出口，否则为无限递归，会出现栈溢出
* 递归可以可以是一个大的问题简单化
* 递归会无限分配栈空间，性能不佳


<details>
<summary>例题: 递归计算阶乘<br/>
</summary>

``` java
public class FactorialRecursionTest {
  public int factorial(int number) {
    return number == 1 || number == 0 ? 1 : number * factorial(number - 1);
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialRecursionTest factorialTest = new FactorialRecursionTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

<details>
<summary>例题: 递归实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    return n == 1 || n == 2 ? 1 : fib(n - 1) + fib(n - 2);
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

<details>
<summary>例题: 迭代实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    int first = 1;
    int second = 1;
    for (int i = 3; i <= n; ++i) {
      int temp = first + second;
      first = second;
      second = temp;
    }
    return second;
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

## 封装
* 对成员属性进行封装，防止非法赋值，赋值前进行合法性检测
* 使用关键词 `private` 私有化成员属性
* 对外提供 `public` 的方法访问私有成员

<details>
<summary>例题: 对象的getter、setter 方法 <br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {
    
  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }
  
  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public static void main(String[] args) {
    Student student = new Student();
    student.setName("杜远超");
    student.setAge(25);
    student.show();
  }
}
```
</details>

<details>
<summary>例题: 录入若干学生信息，并且输出<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {

  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public void input(Student[] students) {
    Scanner scanner = new Scanner(System.in);
    for (int i = 0; i < students.length; ++i) {
      System.out.print("请输入第" + (i + 1) + "学生信息(姓名 年龄): ");
      students[i] = new Student(scanner.next(), scanner.nextInt());
    }
  }

  public void output(Student[] students) {
    System.out.println("学生信息如下");
    System.out.println("姓名\t年龄");
    for (Student student : students) {
      System.out.println(student.getName() + "\t" + student.getAge());
    }
  }

  public   void main(String[] args) {
    System.out.print("请输入学生的人数: ");
    int len = new Scanner(System.in).nextInt();
    Student[] students = new Student[len];

    Student student = new Student();
    student.input(students);
    student.output(students);
  }
}
```
</details>


<details>
<summary>例题: 声明两个Student对象，打印信息<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student(String name, int age) {
    setName(name);
    setAge(age);
  }

  public Student() {
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
      return;
    }
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("非法年龄: " + age);
      return;
    }
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + getName() + ", age = " + getAge());
  }
  public static void main(String[] args) {
    Student stu1 = new Student("Jack", 25);
    Student stu2 = new Student("杜远超", 26);
    stu1.show();
    stu2.show();
  }
}
```
</details>

## static 关键字
* 表示的成员属性或者方法为所有对象共享
* 随着类的加载而初始化，和对象创建与否无关
* 非静态成员方法中可以访问静态和非静态成员
* 静态成员的访问推荐使用类名访问，而不是引用
* 静态成员方法中只能访问静态变量，不能访问非静态成员

<details>
<summary>例题: static统计一个对象被创建了多少次<br/>
</summary>

``` java
public class StaticTest {
  private static int count = 0;

  public StaticTest() {
    count++;
  }
  public static int getCount() {
    return count;
  }

  public static void main(String[] args) {
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了0次
    StaticTest staticTest = new StaticTest();
    StaticTest staticTest1 = new StaticTest();
    StaticTest staticTest2 = new StaticTest();
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了3次
  }
}
```
</details>

<details>
<summary>例题: 打印 main 函数的参数<br/>
</summary>

``` java
public class PrintMainArgs {
  public static void main(String[] args) {
    System.out.println("main方法的参数长度为:" + args.length);
    System.out.println("参数列表为:" + Arrays.toString(args));
  }
}
```
</details>

<details>
<summary>例题: 编写代码实现单例设计模式(Singleton)(饿汉式)<br/>
</summary>

``` java
class Singleton {
  private static final Singleton singleton = new Singleton();
  private Singleton() {

  }

  public static Singleton getInstance() {
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2); // true
}
```
</details>


<details>
<summary>例题: 编写代码实现单例设计模式(Singleton) - 懒汉式(存在线程安全问题，后面解决)<br/>
</summary>

``` java
class Singleton {
  private static Singleton singleton;
  private Singleton() {

  }

  public static Singleton getInstance() {
    if (singleton == null) {
      singleton = new Singleton();
    }
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2);
  }
}
```
</details>

## 继承
* 抽取各个类的共同属性，减少代码的冗余
* 提高代码的复用性，可维护性，扩展性
* 使用关键词 `extends` 实现继承
* 构造方法不能继承
* 私有方法不能继承
* 子类和父类必须是 `is-a` 关系
* 不支持多继承


<details>
<summary>例题: 实现学生类继承人物类<br/>
</summary>

``` java
class People {
  public String name;
  public int age;

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}

class Student extends People {
  private int score;

  public Student(String name, int age, int score) {
    setName(name);
    setAge(age);
    this.score = score;
  }

  public void setScore(int score) {
    this.score = score;
  }

  public int getScore() {
    return score;
  }
}
public class ExtendsTest {
  public static void main(String[] args) {
    Student student = new Student("杜远超", 25, 99);
    student.show(); // name = 杜远超, age = 25
    System.out.println("学生" + student.getName() + "的成绩是" + student.getScore()); // 学生杜远超的成绩是99
  }
}
```
</details>

## 重写(Override)
* 重写从父类继承的方法
* 使用 `super` 关键词访问父类的方法或者成员
* 使用注解`@Verride` 可以标注某个方法为重写方法

<details>
<summary>例题: 重写父类继承而来的方法<br/>
</summary>

``` java
class People {
  public String name;
  public int age;

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}

class Student extends People {
  private int score;

  public Student(String name, int age, int score) {
    super(name, age);
    this.score = score;
  }

  public void setScore(int score) {
    this.score = score;
  }

  public int getScore() {
    return score;
  }

  @Override
  public void show() {
    super.show();
    System.out.println("score = " + score);
  }
}
public class OverrideTest {
  public static void main(String[] args) {
    Student student = new Student("杜远超", 25, 99);
    student.show();
  }
}
```
</details>

## 访问修饰符
* public
* protected
* default
* private

## 包(package)
* 方便管理类
* package 语句必须出现在源代码最前面一行
* 解决类名冲突，方便项目的管理

## 导入import
* 可以在程序中导入jdk，以及其他人编写好的类供本程序的使用
* import static xxx 可以实现静态导入

## 代码块，静态代码块，构造方法的执行顺序
1. 静态代码块
2. 非静态代码块
3. 构造方法

<details>
<summary>例题: 代码块，静态代码块和构造方法的执行顺序<br/>
</summary>

``` java
class MyClass {
  {
    System.out.println("非静态代码块"); // 2
  }
  static {
    System.out.println("静态代码"); // 1
  }
  public MyClass() {
    System.out.println("构造函数"); // 3
  }
}
public class CodeBlockExecuteOrderTest {
  public static void main(String[] args) {
    MyClass myClass = new MyClass();
  }
}
```
</details>

<details>
<summary>例题: 继承关系中代码块，静态代码块和构造方法的执行顺序<br/>
</summary>

``` java
class SuperClass {
  {
    System.out.println("父类的非静态代码块"); // 3
  }
  static {
    System.out.println("父类的静态代码块"); // 1
  }
  public SuperClass() {
    System.out.println("父类构造方法"); // 4
  }
}
class SubClass extends SuperClass{
  {
    System.out.println("子类的非静态代码块"); // 5
  }
  static {
    System.out.println("子类的静态代码块"); // 2
  }
  public SubClass() {
    System.out.println("子类的构造方法"); // 6
  }
}
public class CodeBlockExecuteOrderTest {
  public static void main(String[] args) {
    SubClass subClass = new SubClass();
  }
}
```
</details>

## final 关键词
* final 定义常量，表示不能重新赋值
* final 修饰类表示类不能被继承
* final 修饰方法表示子类不能重写此方法
* final 修饰成员变量必须初始化，或者在代码块，构造方法中初始化，常量均采用大写字母格式，多个单词之间使用 `_` 分隔开
* final 修饰引用变量，表示变量不能重新指向其他对象，但是可以修改指向的对象内容

## 多态
* 父类引用指向子类对象
* 父类引用不可以直接调用子类独有的方法
* 对于父类和子类都存在的方法，编译阶段调用的是父类的方法，运行阶段调用的是子类的方法 (非静态方法)
* 父类引用想调用子类对象独有方法，需要显示转换为子类对象


<details>
<summary>例题: 多态演示<br/>
</summary>

``` java
class Shape {
  private int x;
  private int y;

  public Shape(int x, int y) {
    this.x = x;
    this.y = y;
  }

  public int getX() {
    return x;
  }

  public void setX(int x) {
    this.x = x;
  }

  public int getY() {
    return y;
  }

  public void setY(int y) {
    this.y = y;
  }

  void show() {
    System.out.println("x = " + x + ", y = " + y);
  }
}

class Circle extends Shape {
  private int radius;
  public Circle(int x, int y, int radius) {
    super(x, y);
    this.radius = radius;
  }

  @Override
  void show() {
    System.out.println("x = " + getX() + ", y = " + getY() + ", r = " + radius);
  }

  public double area() {
    return Math.PI * radius * radius;
  }
}
public class PolymorphismTest {
  public static void main(String[] args) {
    Shape shape = new Circle(0, 0, 10);
    shape.show(); // x = 0, y = 0, r = 10
    System.out.println("area = " + ((Circle)shape).area());
  }
}
```
</details>

## instanceof 的使用

<details>
<summary>例题: instanceof<br/>
</summary>

``` java
class Shape {

}
class Circle extends Shape{

}

class Rectangle extends Shape{

}
public class InstanceofTest {
  public static void main(String[] args) {
    Shape shape = new Circle();
    Circle circle;
    if (shape instanceof Circle) {
      circle = (Circle) shape;
    }
  }
}
```
</details>

<details>
<summary>例题: 多态的应用<br/>
</summary>

``` java
class Shape {
  public void draw() {
    System.out.println("绘制图形");
  }
}
class Circle extends Shape{

  @Override
  public void draw() {
    System.out.println("绘制圆形");
  }
}

class Rectangle extends Shape{
  @Override
  public void draw() {
    System.out.println("绘制长方形");
  }
}
class Line extends Shape {
  @Override
  public void draw() {
    System.out.println("绘制线条");
  }
}

public class PolymorphismTest {
  public static void draw(Shape shape) {
    shape.draw();
  }
  public static void main(String[] args) {
    PolymorphismTest.draw(new Circle()); // 绘制圆形
    PolymorphismTest.draw(new Rectangle()); // 绘制长方形
    PolymorphismTest.draw(new Line()); // 绘制线条
  }
}
```
</details>

## 抽象类
* 使用关键词 `abstract` 声明抽象类和抽象方法
* 抽象类可以有成员变量，成员方法，构造方法
* 不能被实例化
* 抽象类中可以没有抽象方法
* 抽象类主要用于子类的继承
* 子类继承抽象类时，必须实现抽象的抽象方法，不然子类也得是抽象类

## 接口
* 比抽象类还抽象
* 使用关键词 `interface` 声明接口
* 接口中的成员变量默认是 `public static final`
* Java 9以后，接口中可以声明 `private` 方法，并且有默认的实现
* 使用关键词 `implements` 实现接口
* 接口支持多继承可以实现多个接口，而类不支持多继承

<details>
<summary>例题: 接口案例<br/>
</summary>

``` java
interface USB {
  void connect();
}
interface Power {
  void charging();
}

class Computer implements USB, Power {

  @Override
  public void connect() {
    System.out.println("链接手机");
  }

  @Override
  public void charging() {
    System.out.println("充电");
  }
}
public class InterfaceTest {
  public static void main(String[] args) {
    Computer computer = new Computer();
    computer.connect();
    computer.charging();
  }
}
```
</details>

## 抽象类和接口的区别
* 抽象类使用关键词 `abstract`，接口使用 `interface`
* 继承抽象类使用关键词 `extends`，实现接口使用 `implements`
* 只能继承一个抽象类，但是可以实现多个接口
* 抽象类可以有构造方法，但是接口中不可以
* 抽象类中可以有成员变量，但是接口中的成员变量默认是 `public static final`
* 抽象类中可以有成员方法，接口中不可以，新版jdk中可以有私有成员方法(java 9)
* 接口中可以使用 `default` 关键词声明默认实现的函数，子类可以决定是否重写

## 内部类

<details>
<summary>例题: 成员内部类<br/>
</summary>

``` java
class OuterClass {
  private int number = 10;
  class InnerClass {
    private int number;

    public InnerClass(int number) {
      this.number = number;
    }
    public void print() {
      System.out.println("内部类的值为: " + this.number);
      System.out.println("外部类的值为: " + OuterClass.this.number);
    }
  }
}
public class MemberInnerClassTest {
  public static void main(String[] args) {
    OuterClass.InnerClass innerClass = new OuterClass().new InnerClass(100);
    innerClass.print();
  }
}
```
</details>

<details>
<summary>例题: 静态内部类<br/>
</summary>

``` java
class OuterClass {
  private static int count = 10;
  public static class InnerClass {
    private static int count;

    public InnerClass(int count) {
      InnerClass.count = count;
    }

    public void show() {
      System.out.println("外部类的值: " + OuterClass.count);
      System.out.println("内部类的值: " + count);
    }
  }
}
public class StaticInnerClassTest {
  public static void main(String[] args) {
    OuterClass.InnerClass innerClass = new OuterClass.InnerClass(100);
    innerClass.show();
  }
}
```
</details>

<details>
<summary>例题: 方法内部类<br/>
</summary>

``` java
public class FunctionInnerClassTest {
  public static void main(String[] args) {
    class People {
      private String name;
      private int age;

      public People(String name, int age) {
        this.name = name;
        this.age = age;
      }

      public String getName() {
        return name;
      }

      public void setName(String name) {
        this.name = name;
      }

      public int getAge() {
        return age;
      }

      public void setAge(int age) {
        this.age = age;
      }

      @Override
      public String toString() {
        return "name = " + name + ", age = " + age;
      }
    }

    People people = new People("杜远超", 25);
    System.out.println(people);
  }
}
```
</details>

<details>
<summary>例题: 接口回调<br/>
</summary>

``` java
interface USB {
  void connect();
}

public class InterfaceCallback {
  public void connectToUSB(USB usb) {
    usb.connect();
  }

  public static void main(String[] args) {
    InterfaceCallback interfaceCallback = new InterfaceCallback();
    interfaceCallback.connectToUSB(new USB() {
      @Override
      public void connect() {
        System.out.println("正在链接USB传送文件...");
      }
    });
  }
}
```
</details>

## 枚举enum
<details>
<summary>例题: 颜色枚举类<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }

  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum whiteColor = ColorEnum.WHITE;
    ColorEnum blueColor = ColorEnum.BLUE;
    System.out.println(whiteColor.getColorDesc());
    System.out.println(blueColor.getColorDesc());
  }
}
```
</details>


<details>
<summary>例题: switch中使用枚举<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }

  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum blackColor = ColorEnum.BLUE;
    switch (blackColor) {
      case BLUE -> System.out.println("蓝色");
      case WHITE -> System.out.println("白色");
      case BLACK -> System.out.println("黑色");
      case RED -> System.out.println("红色");
    }
  }
}
```
</details>

<details>
<summary>例题: 枚举常用内置方法<br/>
</summary>

``` java
enum ColorEnum {
  RED("红色"), WHITE("白色"), BLACK("黑色"), BLUE("绿色");
  private final String colorDesc;

  private ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }
  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum[] colorEnums = ColorEnum.values();
    for (ColorEnum colorEnum : colorEnums) {
      System.out.println(colorEnum.ordinal() + ":" + colorEnum);
    }

    System.out.println(ColorEnum.valueOf("WHITE").getColorDesc());
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.RED));
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.WHITE));
    System.out.println(ColorEnum.BLACK.compareTo(ColorEnum.BLUE));
  }
}
```
</details>

<details>
<summary>例题: 枚举实现接口<br/>
</summary>

``` java
interface MyInterface {
  void print();
}
enum ColorEnum implements MyInterface{
  RED("红色") {
    @Override
    public void print() {
      System.out.println("我是红色");
    }
  }, WHITE("白色") {
    @Override
    public void print() {
      System.out.println("我是白色");
    }
  };
  private final String colorDesc;

  ColorEnum(String colorDesc) {
    this.colorDesc = colorDesc;
  }
  public String getColorDesc() {
    return colorDesc;
  }
}

public class ColorEnumTest {
  public static void main(String[] args) {
    ColorEnum whiteColor = ColorEnum.WHITE;
    whiteColor.print(); // 我是白色
  }
}
```
</details>

