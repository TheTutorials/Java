# 面向对象
* Java 中一切皆对象

## 类的定义
``` java
访问修饰符 class 类名 {
    成员属性和方法定义...
}
```
如
``` java
class Person {
  String name = "Java";
  public void sayHi() {
    System.out.println(name);
  }
}
```

## 类的初始化
* 类是创建对象的模版（蓝图）
* 使用关键词 `new` 创建类对应的实体
* 使用关键词 `new` 创建的对象存储在堆空间里
* 成员变量可以不初始化，有默认值
``` java
class Person {
  String name;
  int age;
}

new Person(); //匿名对象
Person jack = new Person(); //创建对象并保存对象的引用
```

## 访问对象成员
``` java
public class Student {
  String name; //学生姓名
  int age; //学生年龄

  public static void main(String[] args) {
    Student jack = new Student();
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:null，年龄是:0
    jack.name = "Jack"; // 修改姓名
    jack.age = 25; // 修改年龄
    System.out.println("学生的名字:" + jack.name + "，年龄是:" + jack.age); // 学生的名字:Jack，年龄是:25

    Student tom = new Student();
    tom.name = "Tom";
    tom.age = 20;
    System.out.println("学生的名字:" + tom.name + "，年龄是:" + tom.age); // 学生的名字:Tom，年龄是:20
  }
}
```

<details>
<summary>例题: 定义一个Point对象表示点<br/>
</summary>

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    System.out.println("x = " + point.x + ", y = " + point.x);
  }
}
```
</details>

## 方法的定义
``` java
[访问修饰符] 返回值类型 函数名(参数列表) {
  函数体
} 
```

* 访问修饰符: `public` `private` `protect` `default`
* 返回值类型: 8大基本数据类型以及引用类型都可以作为返回值类型，如果不需要返回值，声明为 `void`
* 函数名: 遵循变量命名规则
* 参数列表: 声明函数所需要接受的参数，从主调函数传递而来，如果不需要传递任何参数可以直接空着
* 函数题: 根据参数列表执行相应的运算，然后返回运算结果（如果需要)

``` java
public class Point {
  int x; //x轴
  int y; //y轴

  public void show() {
    System.out.println("x = " + x + ", y = " + x);
  }

  public static void main(String[] args) {
    Point point = new Point();
    point.x = 3;
    point.y = 4;
    point.show();
  }
}
```

## 方法的调用
* 函数名(实际参数)
* 实际参数传递给形式参数用于初始化形式参数
* 实参列表和形参数列表必须保持类型和数量一致
* 实际参数可以传递常量、变量、表达式、方法调用等

<details>
<summary>例题: 定义由参数成员函数修改成员属性值<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄
  double height; //身高

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public void setHeight(double newHeight) {
    height = newHeight;
  }

  public void setInfo(String newName, int newAge, double newHeight) {
    name = newName;
    age = newAge;
    height = newHeight;
  }

  public void showInfo() {
    System.out.println("姓名:" + name + "\t年龄:" + age + "\t身高:" + height);
  }
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.setHeight(2.0);
    people.showInfo();

    People jack = new People();
    jack.setInfo("Jack", 22, 2.21);
    jack.showInfo();
  }
}
```
</details>

## 可变长参数函数定义
* 参数的数量根据实际情况而决定
* 可以是0个或者多个
* 一个方法只允许有一个可变参数，并且只能位于最后一个位置

<details>
<summary>例题: 可变参数求任意个数字求和<br/>
</summary>

``` java
public class VarParametersTest {
  public int sum(int... nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public static void main(String[] args) {
    VarParametersTest varParametersTest = new VarParametersTest();
    System.out.println(varParametersTest.sum()); // 0
    System.out.println(varParametersTest.sum(1)); // 1
    System.out.println(varParametersTest.sum(1, 2)); // 3
    System.out.println(varParametersTest.sum(1, 2, 3)); // 5
    int[] nums = {1, 2, 3, 4, 5};
    System.out.println(varParametersTest.sum(nums)); // 15
  }
}
```
</details>

<details>
<summary>例题: 无参数有返回值案例<br/>
</summary>

``` java
public class People {
  String name; //姓名
  int age; //年龄

  public void setName(String newName) {
    name = newName;
  }

  public void setAge(int newAge) {
    age = newAge;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);

    String returnName = people.getName();
    int returnAge = people.getAge();
    System.out.println(returnName);
    System.out.println(returnAge);
  }
}
```
</details>

注意: 
* 形式参数的改变不会影响实际参数的改变，因为他们存在于不同的栈空间
* 传递引用参数时，形式参数通过引用改变内容，同时回修改实际参数的内容
* 形式参数改变引用指向时候，改变形式参数不会影响到实际参数
``` java
public class ChangeArgs {
  public void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    System.out.println("swap函数中的a = " + a + ", b = " + b); // swap函数中的a = 4, b = 3
  }

  public static void main(String[] args) {
    int a = 3;
    int b = 4;
    System.out.println("交换前: a = " + a + ", b = " + b); // 交换前: a = 3, b = 4
    new ChangeArgs().swap(a, b);
    System.out.println("交换后: a = " + a + ", b = " + b); // 交换后: a = 3, b = 4  
  }
}
```

``` java
public class ChangeArgs {
  public void swap(int[] nums) {
    int temp = nums[0];
    nums[0] = nums[1];
    nums[1] = temp;
  }

  public static void main(String[] args) {
    int[] nums = {3, 4};
    System.out.println("交换前:" + Arrays.toString(nums)); // 交换前:[3, 4]
    new ChangeArgs().swap(nums);
    System.out.println("交换后:" + Arrays.toString(nums)); // 交换后:[4, 3]
  }
}
```

## 方法调用内存结构
* 栈用于存放程序运行时的所有局部变量
* 每次的函数调用会在栈中开辟对应的空间，存储该方法的局部变量
* 方法返回时候，栈顶弹出，返回到上一个主调函数


## 构造方法
* 用于创建对象时，初始化成员属性
* 构造方法没有返回值
* 构造方法方法名和类名保持一致
* 构造方法只能使用 `new` 关键词调用
* 如果没有显示声明构造方法，系统默认添加一个无参数构造方法
* 如果已经定义了构造方法，系统不会默认提供无参构造方法，如果需要需要手动定义

<details>
<summary>例题: 无参数构造方法的调用<br/>
</summary>

``` java
class Computer {
  public String color;
  public double price;
  public Computer() {
    System.out.println("构造方法被调用了");
    color = "红色";
    price = 19999;
  }
  public void showComputerInfo() {
    System.out.println("电脑颜色: " + color + ", 电脑价格: " + price);
  }
}
public class ConstructorTest {
  public static void main(String[] args) {
    Computer computer = new Computer(); // 构造方法被调用了
    computer.showComputerInfo(); // 电脑颜色: 红色, 电脑价格: 19999.0
  }
}
```
</details>

<details>
<summary>例题: 有参数构造函数调用<br/>
</summary>

``` java
class Cat {
  public String color;
  private int age;

  public Cat() {
  }

  public Cat(String initColor, int initAge) {
    color = initColor;
    age = initAge;
  }

  public void showInfo() {
    System.out.println("猫的颜色: " + color + ", 年龄: " + age);
  }
}
public class ConstructorWithArgsTest {
  public static void main(String[] args) {
    Cat cat = new Cat();
    cat.showInfo(); // 猫的颜色: null, 年龄: 0

    cat = new Cat("白色", 10);
    cat.showInfo(); // 猫的颜色: 白色, 年龄: 10
  }
}
```
</details>

## 方法重载(Overload)
* 方法名相同，参数列表不同(参数个数，参数类型，参数顺序)
* 参数列表相同，返回值类型不一致，不算方法重载
* 参数类型相同，但是名字不同也不能算重载

<details>
<summary>例题: 函数重载<br/>
</summary>

``` java
class Sum {
  public int sum(int a, int b) {
    return a + b;
  }

  public int sum(int a, int b, int c) {
    return a + b + c;
  }

  public int sum(int[] nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    return sum;
  }

  public double sum(double[] nums) {
    double sum = 0;
    for (double num : nums) {
      sum += num;
    }
    return sum;
  }
}
public class FunctionOverloadTest {
  public static void main(String[] args) {
    Sum sum = new Sum();
    System.out.println(sum.sum(1, 2)); // 3
    System.out.println(sum.sum(1, 2, 3)); // 6
    System.out.println(sum.sum(new int[]{1, 2, 3, 4})); // 10
    System.out.println(sum.sum(new double[]{1.0, 3.0, 5.0})); // 9.0
  }
}
```
</details>

## `this` 关键词
* 当前类对象的引用
* 构造方法和成员方法中访问成员变量时，默认会在成员变量之前加上 `this` 关键词 
``` java
public class ThisTest {
  public ThisTest() {
    System.out.println("Test:" + this);
  }
  public void test() {
    System.out.println("test:" + this);
  }
  public static void main(String[] args) {
    ThisTest test = new ThisTest();
    System.out.println(test);
    test.test();
  }
}
```

<details>
<summary>例题: this 关键词在构造方法和成员方法中的使用<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setAge(int age) {
    this.age = age;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    People people = new People();
    people.setName("杜远超");
    people.setAge(25);
    people.show();

    people = new People("Jack", 25);
    people.show();
  }
}
```
</details>

<details>
<summary>例题: this 实现链式编程<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {

  }

  public People setName(String name) {
    this.name = name;
    return this;
  }

  public People setAge(int age) {
    this.age = age;
    return this;
  }

  void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People().setName("杜远超").setAge(25).show();
  }
}
```
</details>

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People() {
    this("杜远超", 25);
  }

  public People(String name) {
    this(name, 25);
  }

  public People(int age) {
    this("杜远超", age);
  }

  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class ThisTest {
  public static void main(String[] args) {
    new People("杜远超", 25).show();
    new People("杜远超").show();
    new People(25).show();
    new People().show();
  }
}
```
</details>

调用方法时候注意，必须注意引用对象是否初始化，如果未初始化，则会抛空指针异常

<details>
<summary>例题: this 调用构造函数<br/>
</summary>

``` java
class People {
  public String name;
  public int age;
  public People(String name, int age) {
    this.name = name;
    this.age = age;
  }
  public void show() {
    System.out.println("name = " + name + ", age = " + age);
  }
}
public class NullPointerExceptionTest {
  public static void main(String[] args) {
    People people = null;
    people.show();
  }
}
```
</details>

<details>
<summary>例题: 计算任意数字及以下的所有数字的阶乘结果并打印<br/>
</summary>

``` java
public class FactorialTest {
  public int factorial(int number) {
    int factorial = 1;
    for (int i = 1; i <= number; ++i) {
      factorial *= i;
    }
    return factorial;
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialTest factorialTest = new FactorialTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

## 递归函数
* 函数自身调用自身的过程
* 递归函数必须有递归出口，否则为无限递归，会出现栈溢出
* 递归可以可以是一个大的问题简单化
* 递归会无限分配栈空间，性能不佳


<details>
<summary>例题: 递归计算阶乘<br/>
</summary>

``` java
public class FactorialRecursionTest {
  public int factorial(int number) {
    return number == 1 || number == 0 ? 1 : number * factorial(number - 1);
  }
  public static void main(String[] args) {
    System.out.print("请输入一个数字:");
    int number = new Scanner(System.in).nextInt();

    FactorialRecursionTest factorialTest = new FactorialRecursionTest();
    for (int i = 1; i <= number; ++i) {
      System.out.println(i + "的阶乘是: " + factorialTest.factorial(i));
    }
  }
}
```
</details>

<details>
<summary>例题: 递归实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    return n == 1 || n == 2 ? 1 : fib(n - 1) + fib(n - 2);
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

<details>
<summary>例题: 迭代实现斐波那契数列前n项<br/>
</summary>

``` java
public class FibonacciTest {
  public int fib(int n) {
    int first = 1;
    int second = 1;
    for (int i = 3; i <= n; ++i) {
      int temp = first + second;
      first = second;
      second = temp;
    }
    return second;
  }
  public static void main(String[] args) {
    System.out.print("请输入项数:");
    int n = new Scanner(System.in).nextInt();

    FibonacciTest fibonacciTest = new FibonacciTest();
    for (int i = 1; i <= n; ++i) {
      System.out.print(fibonacciTest.fib(i) + "\t");
      if (i % 5 == 0) {
        System.out.println();
      }
    }
  }
}
```
</details>

## 封装
* 对成员属性进行封装，防止非法赋值，赋值前进行合法性检测
* 使用关键词 `private` 私有化成员属性
* 对外提供 `public` 的方法访问私有成员

<details>
<summary>例题: 对象的getter、setter 方法 <br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {
    
  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }
  
  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public static void main(String[] args) {
    Student student = new Student();
    student.setName("杜远超");
    student.setAge(25);
    student.show();
  }
}
```
</details>

<details>
<summary>例题: 录入若干学生信息，并且输出<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student() {

  }
  public Student(String name, int age) {
    this.setName(name);
    this.setAge(age);
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
    }
    this.name = name;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("年龄不能小于0");
      return;
    }
    this.age = age;
  }

  public String getName() {
    return name;
  }

  public int getAge() {
    return age;
  }

  public void show() {
    System.out.println("姓名: " + name + ", 年龄: " + age);
  }

  public void input(Student[] students) {
    Scanner scanner = new Scanner(System.in);
    for (int i = 0; i < students.length; ++i) {
      System.out.print("请输入第" + (i + 1) + "学生信息(姓名 年龄): ");
      students[i] = new Student(scanner.next(), scanner.nextInt());
    }
  }

  public void output(Student[] students) {
    System.out.println("学生信息如下");
    System.out.println("姓名\t年龄");
    for (Student student : students) {
      System.out.println(student.getName() + "\t" + student.getAge());
    }
  }

  public   void main(String[] args) {
    System.out.print("请输入学生的人数: ");
    int len = new Scanner(System.in).nextInt();
    Student[] students = new Student[len];

    Student student = new Student();
    student.input(students);
    student.output(students);
  }
}
```
</details>


<details>
<summary>例题: 声明两个Student对象，打印信息<br/>
</summary>

``` java
public class Student {
  private String name;
  private int age;

  public Student(String name, int age) {
    setName(name);
    setAge(age);
  }

  public Student() {
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    if (name == null || name.equals("")) {
      System.err.println("姓名不能为空");
      return;
    }
    this.name = name;
  }

  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    if (age < 0) {
      System.err.println("非法年龄: " + age);
      return;
    }
    this.age = age;
  }

  public void show() {
    System.out.println("name = " + getName() + ", age = " + getAge());
  }
  public static void main(String[] args) {
    Student stu1 = new Student("Jack", 25);
    Student stu2 = new Student("杜远超", 26);
    stu1.show();
    stu2.show();
  }
}
```
</details>

## static 关键字
* 表示的成员属性或者方法为所有对象共享
* 随着类的加载而初始化，和对象创建与否无关
* 非静态成员方法中可以访问静态和非静态成员
* 静态成员的访问推荐使用类名访问，而不是引用
* 静态成员方法中只能访问静态变量，不能访问非静态成员

<details>
<summary>例题: static统计一个对象被创建了多少次<br/>
</summary>

``` java
public class StaticTest {
  private static int count = 0;

  public StaticTest() {
    count++;
  }
  public static int getCount() {
    return count;
  }

  public static void main(String[] args) {
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了0次
    StaticTest staticTest = new StaticTest();
    StaticTest staticTest1 = new StaticTest();
    StaticTest staticTest2 = new StaticTest();
    System.out.println("对象被创建了" + StaticTest.getCount() + "次"); // 对象被创建了3次
  }
}
```
</details>

<details>
<summary>例题: 打印 main 函数的参数<br/>
</summary>

``` java
public class PrintMainArgs {
  public static void main(String[] args) {
    System.out.println("main方法的参数长度为:" + args.length);
    System.out.println("参数列表为:" + Arrays.toString(args));
  }
}
```
</details>

<details>
<summary>例题: 编写代码实现单例设计模式(Singleton)(饿汉式)<br/>
</summary>

``` java
class Singleton {
  private static final Singleton singleton = new Singleton();
  private Singleton() {

  }

  public static Singleton getInstance() {
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2); // true
}
```
</details>


<details>
<summary>例题: 编写代码实现单例设计模式(Singleton) - 懒汉式(存在线程安全问题，后面解决)<br/>
</summary>

``` java
class Singleton {
  private static Singleton singleton;
  private Singleton() {

  }

  public static Singleton getInstance() {
    if (singleton == null) {
      singleton = new Singleton();
    }
    return singleton;
  }
}
public class SingletonTest {
  public static void main(String[] args) {
    Singleton singleton1 = Singleton.getInstance();
    Singleton singleton2 = Singleton.getInstance();
    System.out.println(singleton1 == singleton2);
  }
}
```
</details>

## 继承




